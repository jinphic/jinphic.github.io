1. 同源策略：协议、域名、端口 3 者必须都一致才能算是同域的。两个不同域的页面是不能相互读写的。

2. 跨域解决方案：
   2.1 jsonp: 实现方式是通过script标签传递数据，因为script请求不会被同源策略禁止，所以通过script标签去请求跨域数据，并且在script的cb对应func中实现对数据的获取。但是这个只能是get请求。
   2.2 CORS: cross-origin resource sharing， 它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin 上的Web应用被准许访问来自不同源服务器上的指定的资源
   2.3 简单请求：简单请求就是普通 HTML Form 在不依赖脚本的情况下可以发出的请求
      简单请求的 HTTP 方法只能是 GET、HEAD 或 POST
      简单请求的 HTTP 头只能是 Accept/Accept-Language/Conent-Language/Content-Type 等
      简单请求的 Content-Type 头只能是 text/plain、multipart/form-data 或 application/x-www-form-urlencoded
   2.4 非简单请求：
      会有一个预检请求，就是在跨域的时候设置了对应的需要预检的内容,
      结果上会在普通跨域请求前添加了个options请求，用来检查前端headers的修改是否在后端允许范围内
   2.5 Access-Control-Allow-Origin 在需要携带cookie的时候，不能设置为 * ，必须要具体的ip和域名。
      一劳永逸的方法将发起请求的域名，反写到Access-Control-Allow-Origin， 这样子就所有域名都不跨域了。
      这一步可以通过nginx也可以通过node服务。但是不能两个都设置，不然返回的值会是多个，就会报错。
   2.6 换websocket
   2.7 node转发

3. CSRF：
   3.1 原理：Cross-site request forgery 跨站请求伪造
      攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。
   3.2 特点：
      攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
      攻击利用受害者在被攻击网站的登录凭证，冒充受害者提交操作；而不是直接窃取数据。
      整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
      跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪
   3.3 防护：
      3.3.1 阻止不明外域的访问, 同源检测、samesite cookie
         Origin Header
         Referer Header
      3.3.2 提交时要求附加本域才能获取的信息，token、双重cookie验证
         token
            将CSRF Token输出到页面中， 服务器需要给这个用户生成一个Token，否则又会被攻击者冒用
            页面提交的请求携带这个Token
            服务器验证Token是否正确
         双重Cookie采用以下流程：
            在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串（例如csrfcookie=v8g9e4ksfhw）。
            在前端向后端发起请求时，取出Cookie，并添加到URL的参数中（接上例POST https://www.a.com/comment?csrfcookie=v8g9e4ksfhw）。
            后端接口验证Cookie中的字段与URL参数中的字段是否一致，不一致则拒绝。